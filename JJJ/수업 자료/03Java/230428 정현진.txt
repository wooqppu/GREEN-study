타입 변형과 다형성 

다형성 : 메소드 재정의 + 타입 변환 : 다형성 
기본 타입과 마찬가지로 클래스도 타입 변환 가능 

자동타입변환 
자식 타입을 부모타입 변수에 대입하면 자동으로 타입 변환
Child child = new Child;
Parent parent2 = child();
-------------------------------
Parent parent1 = new Child();

Cat cat = new Cat();
Animal animal = cat;
자동타입변환 
Animal animal = new Cat;
(부모 클래스의 객체 뿐만 아니라 부모 클래스 상속받은 모든
자식 타입 객체도 올 수 있다 ---> 자동으로 타입 변환해줌)

부모타입으로 자동타입변환 이후에는 부모 클래스에 
선언된 필드 및 메소드만 접근 가능 (중요)

예외적으로 메소드가 자식 클래스에서 재정의될 경우 
자식 클래스의 메소드가 대신 호출 

강제타입변환
byte byteValue = (byte) intValue
Child child2 = (Child) parent;
자동타입으로 변환된 객체만 강제타입변환 가능 
(Parent parent = new Parent(); ---> 자동타입변환되지
않아서 강제타입변환 불가능)


객체 타입 확인

instanceof 연산자
객체 instanceof 타입 
---> 타입이 맞으면 true, 타입이 맞지않으면 false


강제타입변환 


필드의 다형성 
필드 타입을 부모 타입으로 선언할 경우 
다양한 자식 객체가 저장되어 필드 사용 결과가 달라질 수 있음 

매개변수의 다형성 
매개변수를 부모 타입으로 선언할 경우 메소드 호출 시 
매개값으로 부모 객체 및 모든 자식 객체를 제공할 수 있음
자식의 재정의된 메소드가 호출 -> 다형성


추상클래스 
: 실체클래스의 공통적인 부분(변수, 메서드)을 추출해서 선언한 클래스 
(객체는 실체클래스가 생성)
ex> 동물은 구체적인 실체라기보다는 실체들의 공통되는 특성을 가지고있는 추상적인 것 
- 추상클래스는 객체를 생성할 수 없다 
(실체성이 없고 구체적이지 않기 때문에)
- 추상클래스와 실체클래스는 상속관계 

추상클래스 용도 
1. 공통된 필드와 메서드를 통일할 목적 
- 추상클래스에서 미리 정의한 필드와 메서드가 있다면, 
실체클래스는 추상클래스의 필드와 메서드 명 변경할 수 없고 
무조건 해당 명명으로 구현해야함 
따라서 필드와 메서드 이름을 통일하여 유지보수성을 높이고 통일성 유지 가능 

2. 실체클래스 구현 시, 시간 절약 

3. 규격에 맞는 실체클래스 구현 

추상클래스 선언 : abstract 키워드 
상속 통해서 자식 클래스만 만들 수 있게 만듬(부모 역할만 수행)
직접 객체 생성할 수 없지만 자식클래스로 객체화

추상메소드 
- 메소드 선언만 통일하고 실행 내용은 실제 클래스마다 달라야하는 경우 
- abstract 키워드로 선언되고 중괄호가 없는 메소드 
- 하위 클래스는 반드시 재정의해서 실행 내용을 채워야함 



